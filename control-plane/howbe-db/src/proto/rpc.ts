// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.2
// source: rpc.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Event, KeyValue } from "./kv";
import Long = require("long");

export const protobufPackage = "etcdserverpb";

export interface RangeRequest {
  /** key is the first key for the range. If range_end is not given, the request only looks up key. */
  key: Uint8Array;
  /**
   * range_end is the upper bound on the requested range [key, range_end).
   * If range_end is '\0', the range is all keys >= key.
   * If range_end is key plus one (e.g., "aa"+1 == "ab", "a\xff"+1 == "b"),
   * then the range request gets all keys prefixed with key.
   * If both key and range_end are '\0', then the range request returns all keys.
   */
  rangeEnd: Uint8Array;
  /**
   * limit is a limit on the number of keys returned for the request. When limit is set to 0,
   * it is treated as no limit.
   */
  limit: number;
  /** keys_only when set returns only the keys and not the values. */
  keysOnly: boolean;
  /** count_only when set returns only the count of the keys in the range. */
  countOnly: boolean;
}

export interface RangeResponse {
  kvs: KeyValue[];
  /** count is set to the number of keys within the range when requested. */
  count: number;
}

export interface PutRequest {
  /** key is the key, in bytes, to put into the key-value store. */
  key: Uint8Array;
  /** value is the value, in bytes, to associate with the key in the key-value store. */
  value: Uint8Array;
  /**
   * If prev_kv is set, etcd gets the previous key-value pair before changing it.
   * The previous key-value pair will be returned in the put response.
   */
  prevKv: boolean;
}

export interface PutResponse {
  /** if prev_kv is set in the request, the previous key-value pair will be returned. */
  prevKv: KeyValue | undefined;
}

export interface DeleteRangeRequest {
  /** key is the first key to delete in the range. */
  key: Uint8Array;
  /**
   * range_end is the key following the last key to delete for the range [key, range_end).
   * If range_end is not given, the range is defined to contain only the key argument.
   * If range_end is one bit larger than the given key, then the range is all the keys
   * with the prefix (the given key).
   * If range_end is '\0', the range is all keys greater than or equal to the key argument.
   */
  rangeEnd: Uint8Array;
  /**
   * If prev_kv is set, etcd gets the previous key-value pairs before deleting it.
   * The previous key-value pairs will be returned in the delete response.
   */
  prevKv: boolean;
}

export interface DeleteRangeResponse {
  deleted: number;
  /** if prev_kv is set in the request, the previous key-value pairs will be returned. */
  prevKvs: KeyValue[];
}

export interface WatchRequest {
  createRequest?: WatchCreateRequest | undefined;
  cancelRequest?: WatchCancelRequest | undefined;
}

export interface WatchCreateRequest {
  /** key is the key to register for watching. */
  key: Uint8Array;
  /**
   * range_end is the end of the range [key, range_end) to watch. If range_end is not given,
   * only the key argument is watched. If range_end is equal to '\0', all keys greater than
   * or equal to the key argument are watched.
   * If the range_end is one bit larger than the given key,
   * then all keys with the prefix (the given key) will be watched.
   */
  rangeEnd: Uint8Array;
  /** filters filter the events at server side before it sends back to the watcher. */
  filters: WatchCreateRequest_FilterType[];
  watchId: number;
}

export enum WatchCreateRequest_FilterType {
  /** NOPUT - filter out put event. */
  NOPUT = 0,
  /** NODELETE - filter out delete event. */
  NODELETE = 1,
  UNRECOGNIZED = -1,
}

export function watchCreateRequest_FilterTypeFromJSON(object: any): WatchCreateRequest_FilterType {
  switch (object) {
    case 0:
    case "NOPUT":
      return WatchCreateRequest_FilterType.NOPUT;
    case 1:
    case "NODELETE":
      return WatchCreateRequest_FilterType.NODELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WatchCreateRequest_FilterType.UNRECOGNIZED;
  }
}

export function watchCreateRequest_FilterTypeToJSON(object: WatchCreateRequest_FilterType): string {
  switch (object) {
    case WatchCreateRequest_FilterType.NOPUT:
      return "NOPUT";
    case WatchCreateRequest_FilterType.NODELETE:
      return "NODELETE";
    case WatchCreateRequest_FilterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WatchCancelRequest {
  /** watch_id is the watcher id to cancel so that no more events are transmitted. */
  watchId: number;
}

export interface WatchResponse {
  /** watch_id is the ID of the watcher that corresponds to the response. */
  watchId: number;
  /**
   * created is set to true if the response is for a create watch request.
   * The client should record the watch_id and expect to receive events for
   * the created watcher from the same stream.
   * All events sent to the created watcher will attach with the same watch_id.
   */
  created: boolean;
  /**
   * canceled is set to true if the response is for a cancel watch request.
   * No further events will be sent to the canceled watcher.
   */
  canceled: boolean;
  /** cancel_reason indicates the reason for canceling the watcher. */
  cancelReason: string;
  events: Event[];
}

function createBaseRangeRequest(): RangeRequest {
  return { key: new Uint8Array(0), rangeEnd: new Uint8Array(0), limit: 0, keysOnly: false, countOnly: false };
}

export const RangeRequest = {
  encode(message: RangeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.rangeEnd.length !== 0) {
      writer.uint32(18).bytes(message.rangeEnd);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int64(message.limit);
    }
    if (message.keysOnly !== false) {
      writer.uint32(32).bool(message.keysOnly);
    }
    if (message.countOnly !== false) {
      writer.uint32(40).bool(message.countOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RangeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rangeEnd = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.keysOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.countOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RangeRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      rangeEnd: isSet(object.rangeEnd) ? bytesFromBase64(object.rangeEnd) : new Uint8Array(0),
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      keysOnly: isSet(object.keysOnly) ? globalThis.Boolean(object.keysOnly) : false,
      countOnly: isSet(object.countOnly) ? globalThis.Boolean(object.countOnly) : false,
    };
  },

  toJSON(message: RangeRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.rangeEnd.length !== 0) {
      obj.rangeEnd = base64FromBytes(message.rangeEnd);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.keysOnly !== false) {
      obj.keysOnly = message.keysOnly;
    }
    if (message.countOnly !== false) {
      obj.countOnly = message.countOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RangeRequest>, I>>(base?: I): RangeRequest {
    return RangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RangeRequest>, I>>(object: I): RangeRequest {
    const message = createBaseRangeRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.rangeEnd = object.rangeEnd ?? new Uint8Array(0);
    message.limit = object.limit ?? 0;
    message.keysOnly = object.keysOnly ?? false;
    message.countOnly = object.countOnly ?? false;
    return message;
  },
};

function createBaseRangeResponse(): RangeResponse {
  return { kvs: [], count: 0 };
}

export const RangeResponse = {
  encode(message: RangeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.kvs) {
      KeyValue.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.count !== 0) {
      writer.uint32(16).int64(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RangeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kvs.push(KeyValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RangeResponse {
    return {
      kvs: globalThis.Array.isArray(object?.kvs) ? object.kvs.map((e: any) => KeyValue.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: RangeResponse): unknown {
    const obj: any = {};
    if (message.kvs?.length) {
      obj.kvs = message.kvs.map((e) => KeyValue.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RangeResponse>, I>>(base?: I): RangeResponse {
    return RangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RangeResponse>, I>>(object: I): RangeResponse {
    const message = createBaseRangeResponse();
    message.kvs = object.kvs?.map((e) => KeyValue.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    return message;
  },
};

function createBasePutRequest(): PutRequest {
  return { key: new Uint8Array(0), value: new Uint8Array(0), prevKv: false };
}

export const PutRequest = {
  encode(message: PutRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.prevKv !== false) {
      writer.uint32(24).bool(message.prevKv);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.prevKv = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      prevKv: isSet(object.prevKv) ? globalThis.Boolean(object.prevKv) : false,
    };
  },

  toJSON(message: PutRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.prevKv !== false) {
      obj.prevKv = message.prevKv;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutRequest>, I>>(base?: I): PutRequest {
    return PutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutRequest>, I>>(object: I): PutRequest {
    const message = createBasePutRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    message.prevKv = object.prevKv ?? false;
    return message;
  },
};

function createBasePutResponse(): PutResponse {
  return { prevKv: undefined };
}

export const PutResponse = {
  encode(message: PutResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prevKv !== undefined) {
      KeyValue.encode(message.prevKv, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prevKv = KeyValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutResponse {
    return { prevKv: isSet(object.prevKv) ? KeyValue.fromJSON(object.prevKv) : undefined };
  },

  toJSON(message: PutResponse): unknown {
    const obj: any = {};
    if (message.prevKv !== undefined) {
      obj.prevKv = KeyValue.toJSON(message.prevKv);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutResponse>, I>>(base?: I): PutResponse {
    return PutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutResponse>, I>>(object: I): PutResponse {
    const message = createBasePutResponse();
    message.prevKv = (object.prevKv !== undefined && object.prevKv !== null)
      ? KeyValue.fromPartial(object.prevKv)
      : undefined;
    return message;
  },
};

function createBaseDeleteRangeRequest(): DeleteRangeRequest {
  return { key: new Uint8Array(0), rangeEnd: new Uint8Array(0), prevKv: false };
}

export const DeleteRangeRequest = {
  encode(message: DeleteRangeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.rangeEnd.length !== 0) {
      writer.uint32(18).bytes(message.rangeEnd);
    }
    if (message.prevKv !== false) {
      writer.uint32(24).bool(message.prevKv);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRangeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rangeEnd = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.prevKv = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRangeRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      rangeEnd: isSet(object.rangeEnd) ? bytesFromBase64(object.rangeEnd) : new Uint8Array(0),
      prevKv: isSet(object.prevKv) ? globalThis.Boolean(object.prevKv) : false,
    };
  },

  toJSON(message: DeleteRangeRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.rangeEnd.length !== 0) {
      obj.rangeEnd = base64FromBytes(message.rangeEnd);
    }
    if (message.prevKv !== false) {
      obj.prevKv = message.prevKv;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRangeRequest>, I>>(base?: I): DeleteRangeRequest {
    return DeleteRangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRangeRequest>, I>>(object: I): DeleteRangeRequest {
    const message = createBaseDeleteRangeRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.rangeEnd = object.rangeEnd ?? new Uint8Array(0);
    message.prevKv = object.prevKv ?? false;
    return message;
  },
};

function createBaseDeleteRangeResponse(): DeleteRangeResponse {
  return { deleted: 0, prevKvs: [] };
}

export const DeleteRangeResponse = {
  encode(message: DeleteRangeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deleted !== 0) {
      writer.uint32(8).int64(message.deleted);
    }
    for (const v of message.prevKvs) {
      KeyValue.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRangeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.deleted = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prevKvs.push(KeyValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRangeResponse {
    return {
      deleted: isSet(object.deleted) ? globalThis.Number(object.deleted) : 0,
      prevKvs: globalThis.Array.isArray(object?.prevKvs) ? object.prevKvs.map((e: any) => KeyValue.fromJSON(e)) : [],
    };
  },

  toJSON(message: DeleteRangeResponse): unknown {
    const obj: any = {};
    if (message.deleted !== 0) {
      obj.deleted = Math.round(message.deleted);
    }
    if (message.prevKvs?.length) {
      obj.prevKvs = message.prevKvs.map((e) => KeyValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRangeResponse>, I>>(base?: I): DeleteRangeResponse {
    return DeleteRangeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRangeResponse>, I>>(object: I): DeleteRangeResponse {
    const message = createBaseDeleteRangeResponse();
    message.deleted = object.deleted ?? 0;
    message.prevKvs = object.prevKvs?.map((e) => KeyValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWatchRequest(): WatchRequest {
  return { createRequest: undefined, cancelRequest: undefined };
}

export const WatchRequest = {
  encode(message: WatchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.createRequest !== undefined) {
      WatchCreateRequest.encode(message.createRequest, writer.uint32(10).fork()).ldelim();
    }
    if (message.cancelRequest !== undefined) {
      WatchCancelRequest.encode(message.cancelRequest, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createRequest = WatchCreateRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cancelRequest = WatchCancelRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchRequest {
    return {
      createRequest: isSet(object.createRequest) ? WatchCreateRequest.fromJSON(object.createRequest) : undefined,
      cancelRequest: isSet(object.cancelRequest) ? WatchCancelRequest.fromJSON(object.cancelRequest) : undefined,
    };
  },

  toJSON(message: WatchRequest): unknown {
    const obj: any = {};
    if (message.createRequest !== undefined) {
      obj.createRequest = WatchCreateRequest.toJSON(message.createRequest);
    }
    if (message.cancelRequest !== undefined) {
      obj.cancelRequest = WatchCancelRequest.toJSON(message.cancelRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchRequest>, I>>(base?: I): WatchRequest {
    return WatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchRequest>, I>>(object: I): WatchRequest {
    const message = createBaseWatchRequest();
    message.createRequest = (object.createRequest !== undefined && object.createRequest !== null)
      ? WatchCreateRequest.fromPartial(object.createRequest)
      : undefined;
    message.cancelRequest = (object.cancelRequest !== undefined && object.cancelRequest !== null)
      ? WatchCancelRequest.fromPartial(object.cancelRequest)
      : undefined;
    return message;
  },
};

function createBaseWatchCreateRequest(): WatchCreateRequest {
  return { key: new Uint8Array(0), rangeEnd: new Uint8Array(0), filters: [], watchId: 0 };
}

export const WatchCreateRequest = {
  encode(message: WatchCreateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.rangeEnd.length !== 0) {
      writer.uint32(18).bytes(message.rangeEnd);
    }
    writer.uint32(26).fork();
    for (const v of message.filters) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.watchId !== 0) {
      writer.uint32(32).int64(message.watchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchCreateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rangeEnd = reader.bytes();
          continue;
        case 3:
          if (tag === 24) {
            message.filters.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.filters.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.watchId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchCreateRequest {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      rangeEnd: isSet(object.rangeEnd) ? bytesFromBase64(object.rangeEnd) : new Uint8Array(0),
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => watchCreateRequest_FilterTypeFromJSON(e))
        : [],
      watchId: isSet(object.watchId) ? globalThis.Number(object.watchId) : 0,
    };
  },

  toJSON(message: WatchCreateRequest): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.rangeEnd.length !== 0) {
      obj.rangeEnd = base64FromBytes(message.rangeEnd);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => watchCreateRequest_FilterTypeToJSON(e));
    }
    if (message.watchId !== 0) {
      obj.watchId = Math.round(message.watchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchCreateRequest>, I>>(base?: I): WatchCreateRequest {
    return WatchCreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchCreateRequest>, I>>(object: I): WatchCreateRequest {
    const message = createBaseWatchCreateRequest();
    message.key = object.key ?? new Uint8Array(0);
    message.rangeEnd = object.rangeEnd ?? new Uint8Array(0);
    message.filters = object.filters?.map((e) => e) || [];
    message.watchId = object.watchId ?? 0;
    return message;
  },
};

function createBaseWatchCancelRequest(): WatchCancelRequest {
  return { watchId: 0 };
}

export const WatchCancelRequest = {
  encode(message: WatchCancelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.watchId !== 0) {
      writer.uint32(8).int64(message.watchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchCancelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchCancelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.watchId = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchCancelRequest {
    return { watchId: isSet(object.watchId) ? globalThis.Number(object.watchId) : 0 };
  },

  toJSON(message: WatchCancelRequest): unknown {
    const obj: any = {};
    if (message.watchId !== 0) {
      obj.watchId = Math.round(message.watchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchCancelRequest>, I>>(base?: I): WatchCancelRequest {
    return WatchCancelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchCancelRequest>, I>>(object: I): WatchCancelRequest {
    const message = createBaseWatchCancelRequest();
    message.watchId = object.watchId ?? 0;
    return message;
  },
};

function createBaseWatchResponse(): WatchResponse {
  return { watchId: 0, created: false, canceled: false, cancelReason: "", events: [] };
}

export const WatchResponse = {
  encode(message: WatchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.watchId !== 0) {
      writer.uint32(8).int64(message.watchId);
    }
    if (message.created !== false) {
      writer.uint32(16).bool(message.created);
    }
    if (message.canceled !== false) {
      writer.uint32(24).bool(message.canceled);
    }
    if (message.cancelReason !== "") {
      writer.uint32(34).string(message.cancelReason);
    }
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.watchId = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.created = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canceled = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cancelReason = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchResponse {
    return {
      watchId: isSet(object.watchId) ? globalThis.Number(object.watchId) : 0,
      created: isSet(object.created) ? globalThis.Boolean(object.created) : false,
      canceled: isSet(object.canceled) ? globalThis.Boolean(object.canceled) : false,
      cancelReason: isSet(object.cancelReason) ? globalThis.String(object.cancelReason) : "",
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
    };
  },

  toJSON(message: WatchResponse): unknown {
    const obj: any = {};
    if (message.watchId !== 0) {
      obj.watchId = Math.round(message.watchId);
    }
    if (message.created !== false) {
      obj.created = message.created;
    }
    if (message.canceled !== false) {
      obj.canceled = message.canceled;
    }
    if (message.cancelReason !== "") {
      obj.cancelReason = message.cancelReason;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchResponse>, I>>(base?: I): WatchResponse {
    return WatchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchResponse>, I>>(object: I): WatchResponse {
    const message = createBaseWatchResponse();
    message.watchId = object.watchId ?? 0;
    message.created = object.created ?? false;
    message.canceled = object.canceled ?? false;
    message.cancelReason = object.cancelReason ?? "";
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

export interface KV {
  /** Range gets the keys in the range from the key-value store. */
  Range(request: RangeRequest): Promise<RangeResponse>;
  /**
   * Put puts the given key into the key-value store.
   * A put request increments the revision of the key-value store
   * and generates one event in the event history.
   */
  Put(request: PutRequest): Promise<PutResponse>;
  /**
   * DeleteRange deletes the given range from the key-value store.
   * A delete request increments the revision of the key-value store
   * and generates a delete event in the event history for every deleted key.
   */
  DeleteRange(request: DeleteRangeRequest): Promise<DeleteRangeResponse>;
}

export const KVServiceName = "etcdserverpb.KV";
export class KVClientImpl implements KV {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || KVServiceName;
    this.rpc = rpc;
    this.Range = this.Range.bind(this);
    this.Put = this.Put.bind(this);
    this.DeleteRange = this.DeleteRange.bind(this);
  }
  Range(request: RangeRequest): Promise<RangeResponse> {
    const data = RangeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Range", data);
    return promise.then((data) => RangeResponse.decode(_m0.Reader.create(data)));
  }

  Put(request: PutRequest): Promise<PutResponse> {
    const data = PutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Put", data);
    return promise.then((data) => PutResponse.decode(_m0.Reader.create(data)));
  }

  DeleteRange(request: DeleteRangeRequest): Promise<DeleteRangeResponse> {
    const data = DeleteRangeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteRange", data);
    return promise.then((data) => DeleteRangeResponse.decode(_m0.Reader.create(data)));
  }
}

export interface Watch {
  /**
   * Watch watches for events happening or that have happened. Both input and output
   * are streams; the input stream is for creating and canceling watchers and the output
   * stream sends events. One watch RPC can watch on multiple key ranges, streaming events
   * for several watches at once. The entire event history can be watched starting from the
   * last compaction revision.
   */
  Watch(request: Observable<WatchRequest>): Observable<WatchResponse>;
}

export const WatchServiceName = "etcdserverpb.Watch";
export class WatchClientImpl implements Watch {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || WatchServiceName;
    this.rpc = rpc;
    this.Watch = this.Watch.bind(this);
  }
  Watch(request: Observable<WatchRequest>): Observable<WatchResponse> {
    const data = request.pipe(map((request) => WatchRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "Watch", data);
    return result.pipe(map((data) => WatchResponse.decode(_m0.Reader.create(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
